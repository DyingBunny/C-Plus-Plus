class person
{
public:
	void print()
	{
		cout << "name" << _name << endl;
		cout << "age" << _age << endl;
	}
 
protected:
	string _name = "Jack";
	int _age = 18;
};
 
class Teacher :public person
{
protected:
	int _job;
};
 
int main()
{
	person s;
	Teacher t;
	s.print();
	t.print();
	system("pause");
	return 0;
}

class person
{
public:
	void print()
	{
		cout << "name" << _name << endl;
		cout << "age" << _age << endl;
	}
 
protected:
	string _name = "Jack";
	int _age = 18;
};
 
class Teacher :public person
{
protected:
	int _job;
};

//B中的fun和A中的fun不构成重载，因为处在不同的作用域内
//B中的fun和A中的fun构成隐藏，成员函数如果名字相同的话就构成隐藏关系
 
class A
{
public:
	void fun()
	{
		cout << "func()" << endl;
	}
};
 

class B :public A
{
public:
	void fun(int i)
	{
		A::fun();
		cout << "func(int i)->" << i << endl;
	}
};
 
void Test()
{
	B b;
	b.fun(10);
}
 
int main()
{
	Test();
	system("pause");
	return 0;
}
//Person和Student中_num形成混淆，需要指定作用域

class Person
{
protected:
	string _name = "Jack";
	int _num = 111;
};
 
class Student :public Person
{
public:
	void Print()
	{
		cout << _name << endl;
		cout << Person::_num << endl;
		cout << _num << endl;
	}
protected:
	int _num=999;
};
 
void Test()
{
	Student s1;
	s1.Print();
}
 
int main()
{
	Test();
	system("pause");
	return 0;
}

class Person
{
public:
	//构造函数
	Person(const char* name = "peter")//缺省参数
		:_name(name)
	{
		cout << "Person()" << endl;
	}
 
	Person& operator=(const Person& p)//等号运算符的重载
	{
		cout << "Person operator=(const Person& p)" << endl;
		if (this != &p)
		{
			_name = p._name;
		}
		return *this;
	}
	
	~Person()//析构函数，这边不进行空间的释放，只是用来判断析构函数是否执行
	{
		cout << "~Person()" << endl;
	}
protected:
	string _name;
};
 
class Student :public Person
{
public:
	Student(const char* name, int num)
		:Person(name)
		, _num(num)
	{
		cout << "Student()" << endl;
	}
	Student(const Student& s)//拷贝构造函数
		:Person(s)
		, _num(s._num)
	{
		cout << "Student(const Student& s)" << endl;
	}
 
	Student& operator=(const Student& s)
	{
		cout << "Studnet operator=(const Student& s)" << endl;
		if (this != &s)
		{
			Person::operator=(s);
			_num = s._num;
		}
		return *this;
	}
 
	~Student()
	{
		cout << "~Student()" << endl;
	}
 
protected:
	int _num;
};
 
void Test()
{
	Student s1("jack", 18);
	Student s2(s1);
	Student s3("rose", 17);
	s1 = s3;
}
 
int main()
{
	Test();
	system("pause");
	return 0;
}

//友元的关系无法进程，下面的代码中，Student中的_stuNUm是protected,即使是public继承了
//Person，其中的frined友元函数并不会继承，因此_stuNum是无法访问的
class Student;
 
class Person
{
public:
	friend void Display(const Person& p, const Student& s);
protected:
	string _name;
};
 
class Student :public Person
{
protected:
	int _stuNum;
};
 
void Display(const Person& p, const Student& s)
{
	cout << p._name << endl;
	cout << s._stuNum << endl;
}
 
int main()
{
	Person p;
	Student s;
	Display(p, s);
	system("pause");
	return 0;
}

class Person
{
public:
	Person()
	{
		++_cout;
	}
protected:
	string _name;//姓名
public:
	static int _cout;//统计的人数
};
 
int Person::_cout = 0;
 
class Student :public Person
{
protected:
	int _stuNum;
};
 
class Graduate:public Student
{
protected:
	string  _seminarCourse;
};
 
void Test()
{
	Student s1;
	Student s2;
	Student s3;
	Graduate s4;
	cout << "人数：" << Person::_cout << endl;
	Student::_cout = 0;
	cout << "人数：" << Person::_cout << endl;
}
 
int main()
{
	Test();
	system("pause");
	return 0;
}
